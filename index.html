<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resumen Clean Code Robert C. Martin</title>
</head>
<body>
    <div class="container">
        <h1>Resumen Clean Code de Robert C. Martin</h1>
        <section>
            <h2>Prólogo de James O. Coplien</h2>
            <article>
                <p>
                    <blockquote>"La honestidad por las cosas pequeñas no es algo menor."</blockquote>
                    <blockquote>"Dios está en los detalles".Ludwig mies van der Rohe</blockquote>   
                </p>                               
            </article>
            <article>
                <p>*<u>Las cosas pequeñas importan.</u></p>
                <p>*<u>La práctica del software correcto requiere disciplina</u></p>
                <p><b>TPM(Total Productive Maintanance)Mantenimiento Productivo Total</b> (Se centra en el mantenimiento y no en la producción)</p>
            </article>
            <h3>TPM LEAN 5S</h3>
            <ol>
                <li>
                    Seiri(Organización): es fundamental saber dónde estan las cosas. Uso de nombres correctos.
                </li>
                <li>
                    Seiton(Sistematización):<i>"Un sitio para cada cosa y cada cosa en su sitio". </i>Un fragmento de código debe esar donde esperamos encontrarlo; en caso contrario Refactorice hasta conseguirlo
                </li>
                <li>
                    Seiso(Limpieza): Evita innundar el codigo de comentarios.
                </li>
                <li>
                    Seiketsu(Estandarización): El grupo decide cómo mantener limpio el lugar de trabajo.
                </li>
                <li>
                    Shutsuke(Disciplina): Ser disciplinado en la aplicación de las prácticas y reflejarlas en el trabajo y aceptar los cambios. 
                </li>
            </ol>
            <p><b>REFACTORIZAR CODIGO sin compasión.(Cambiar la extructura interna sin cambiar su comportamiento externo)</b></p>
            <p>¿Hemos refactorizado el código antes de terminarlo?</p> 
            <p>La base de los valores <b>AGILE</b>: <b>SCRUM</b>(Recomienda que la <b>REFACTORIZACION</b> sea parte del concepto <b>TERMINADO</b>)</p>

        </section>
        <section>
            <h2>Introducción</h2>
            <article>
                <p>*La maestría se consigue de dos formas: <b>CONOCIMIENTOS</b> y <b>TRABAJO.</b></p>
                <p>Debe adquirir el conocimiento de los principios, patrones, prácticas y heurística propios de un maestro, y dominar dichos conocimentos a través de la práctica.</p>
                <p>*<u>Apreder a crear código limplio es complicado.</u></p>
                <p>Requiere algo más que conocer principios y patrones. Tiene que sudar. Debe practicarlo y fallar. Debe ver cómo agonizan en cada decisión y el precio que pagan por tomar decisiones equivocadas.</p>
            </article>
        </section>
        <section>
            <h2>Capítulo 1</h2>
            <article>
                <h3>Hágase el código</h3>
                <p>El código nunca desaparecerá, ya que representa los <b>detalles de los requisitos</b>. En algún nivel, dichos detalles no se pueden ignorar ni abstraer; deben espesificarse, y para especificar requisitos de forma que un equipo pueda ejecutarlos se necesita la <b>programación</b>. Dicha especificación es el código</b> </p>
                <dfn>El que piense que el código va a desaparecer es como el matemático que espera que un día las matemáticas no sean formales.</dfn>
                <p>Recuerde que el código es básicamente el lenguaje en el que expresamos los requisitos en última instancia</p>
            </article>
            <article>
                <h3>Código Incorrecto</h3>

            </article>
        </section>
        <section>
            <h2>Cápitulo 2 Nombres con sentido</h2>
            <h3>Reglas básicas para crear nombres correctos.</h3>
            <article>
                <h3>Usar nombres que revelen las intensiones</h3>
                <p>Elegir nombres correctos lleva tiempo pero ahora trabajo.</p>
                <p>El nombre de una variable, función o clase debe responder a una serie de cuestiones básicas:</p>
                <ul>
                    <li>¿Por qué existe?</li>
                    <li>¿Qué hace?</li>
                    <li>¿Cómo se usa?</li>
                </ul> 
                <p>Ejemplos:</p>               
                <div>
                   <code>int elapsedTimeInDays; </code>
                </div>
                <div>   
                    <code>int daysSinceCreation;</code>
                </div>
                <div>
                    <code>int daysSinceModification;</code>
                </div>
                <div>    
                    <code>int fileAgeDays;</code>                
                </div>                 
            </article>
            <p>...</p>
            <article>
                <h3>Evitar la desinformación</h3>
                <ul>
                    <li>Evitar palabras cuyo significado de aleje del que pretendemos. Por ejemplo, <b><del>hp</del></b>, <b><del>aix</del></b> y <b><del>sco</del></b> Son variables pobres.</li>
                    <li>No haga referencia a un grupo de cuentas como <b>accountList</b> a menos que sea una lista (List)</li>
                    <li>Evite usar nombres con variaciones mínimas Ej. <b><del>XYZControllerForEfficentHandlingOfStrings</del></b> y <b><del>XYZControllerForEfficentStorageOfStrings</del></b>.</li>
                    <li>Evite usar l mínuncula y la O mayúsculas como nombre de variables.El problema, evidentemente es que se parecen a las constantes númericas 0 y 1 respectivamente.</li>
                </ul>    
            </article>
            <article>
                <h3>Realizar disticiones con sentido</h3>
                <p>Evite distinciones con el mismo significado.Ej.<b><del>Product</del></b> y <b><del>theProduct</del></b></p>
                <p>Debe diferenciar los nombres de forma que el lector aprecie las diferencias.</p>
            </article>
            <article>
                <h3>Usar nombres que se puedan pronunciar.</h3>
                <p>Evite casos como el siguiente <b>private Date <del>genymdhms </del>;</b>. Lo correcto seria: <b>private Date generationTimestamp;</b></p>
            </article>
            <article>
                <h3>Usar nombres que se puedan buscar</h3>
                <p>Los nombres de una letra y las constantes numéricas tiene un problema: no son fáciles de localizar en el código</p>
                <p>El nombre <b>e</b> es una opción muy pobre para variables que el programador tenga que buscar</p>
                <p><b><u>Nota</u></b>: Usar nombres de una sola letra que solo se puedan usar como variables locales dentro de métodos breves.</p>                
            </article>
            <article>
                <h3>Evitar codificaciones</h3>
                <p>Ya tenemos suficientes codificaciones como para tener que añadir otras nuevas</p>
                <p>Al codificar información de tipos o ámbitos en un nombre se dificulta la decodificación</p>
                <p>Además es uan carga mental innecesaria a la hora de itentar solucionar un problema</p>
                <p>Los nombres codificados resultan inpronunciables y suelen escribirse de forma incorrecta</p>
            </article>
            <article>
                <h3>Notación Húngara (HN)</h3>
                <p>En la actualidad la NH y otras formas de codificación de tipo no es más que un impedimento.
                    <ul>
                        <li>Hacen que pueda ser más complicado cambiarle el nombre o el tipo de una variable o clase. </li>
                        <li>Dificultan la legibilidad del código</li>
                        <li>Pueden hacer que el sistema de codificación confunda al lector</li>                        
                    </ul>    
                    <p>En los leguajes omodernos disponemos de sistemas de tipado más completos y los compliladores recuerdan los tipos y los aplican, por lo que no es necesario usar la HN </p>
            </article>
            <article>
                <h3>Prefijos de miembros</h3>
                <p>No es necesario añadirle prefijos a los nombres de variables. Son un indicio de código antiguo</p>
            </article>
            <article>
                <h3>Interfaces e implementaciones</h3>
                <p>Existe un caso especial para las codificaciones</p>
                <p>Mejor codificar la implementación.Ej.<b>ShapeFactoryImp</b> o incluso, <b>CShapeFactory</b>, que codificar la interfaz</p>                    
            </article>
            <article>
                <h3>Evitar asignaciones mentales</h3>
                <p>Los lectores no tiene que traducir mentalmente sus nombres en otros que ya conocen.</p>
                <p>Es un problema de los nombres de variables de una sola letra, estos son tradicionales en contadores de bucles(i,j,k) si su ambito es muy reducido y no hay conflicto con otros nombres. Sin embargo, en otros contextos pueden ser un nombre de variable muy pobre</p>
                <p>Una diferencia entre un programador inteligente y un programador profesional es que este último sabe que la claridad es lo que importa.</b></p>
                <p><b>Los profesionales usan sus poderes para hacer el bien y crean código que otros puedan entender.</b></p>
            </article>
            <article>
                <h3>Nombres de clase</h3>
                <p>Las clases y los objetos deben tener nombres o fraces como <b>Customer</b>, <b>WikiPage</b>, <b>Account</b>, <b>AddressParser</b></p>
                <p><u>Nota</u>: Evitar palabras como <del>Manager</del>, <del>Processor</del>, <del>Data</del> o <del>Info</del>, en el nombre de una clase.</p>
                <p>El nombre de una clase no dede ser un verbo.</p>
            </article> 
            <article>
                <h3>Nombres de métodos</h3>
                <p>Los métodos deben tener nombres de verbo como <b>postPayment</b>, <b>deletePage</b> o <b>save</b>.</p>
                <p>Los métodos de acceso, modificación o los predicados deben tener como nombre su valor y usar como prefijos <b>get</b>, <b>set</b> e <b>is</b>, de acuerdo a los estándares de <b>javabean.</b></p>
                <pre>
                    <code>
                    string name = employee.getName();
                    customer.setName("miki");
                    if(paycheck.isPosted())...
                </code>
                </pre>
                <p>Al sobre cargar constructores, use métodos de factoría estáticos con nombres que describan los argumentos. Por ejemplo:
                    <pre><code>Complex fulcrumPoint = Complex.FromRealNumber(23.0);</code></pre>
                    <p>Es mejor que:</p>
                    <pre><code>Complex fulcrumPoint = new Complex(23.0);</code></pre>
                </p>
            </article>
            <article>
                <h3>No se exceda con el atractivo</h3>
                <p>Opte por la calidad antes que por el entretenimiento.</p> 
                <p>No recurra a bromas culturales como <del>eatMyShorts()</del> si quiere decir <b>abort()</b>.</p>
                <dfn>"Diga lo que piense. Piense lo que diga".</dfn>                
            </article>
            <p>...</p>  
            <article>
                <h3>Una palabra por concepto</h3>
                <p>Elija una palabra para cada concepto abstracto y manténgala.</p>
                <p>Por ejemplo, resulta confuso usar <b>fetch</b>, <b>retrieve</b>, <b>get</b> como métodos equivalentes de clases distintas. ¿Cómo va a recordar que método corresponde a cada clase?</p>
                <p>¿Cuál es la diferencia entre <b>DeviceManager</b> y <b>ProtocolController</b>?....el nombre hace que esperes que dos objetos tengan un tipo diferente y clases diferentes</p>
                <p><u><b>Nota</b></u>:Un lexico coherente es una gran ventaja para los programadores que tengan que usar su código</p>
            </article>
            <p>...</p>
            <article>
                <h3>No haga juego de palabras</h3>
            </article>
            <p>...</p>
            <article>
                <h3>Usar nombres de dominio de soluciones</h3>
            </article>
            <p>...</p>
            <article>
                <h3>Usar nombres de dominios de problemas</h3>
            </article>
            <p>...</p>
            <article>
                <h3>Añadir contexto con sentido</h3>
            </article>
            <p>...</p>
            <article>
                <h3>No añadir contextos innecesarios</h3>
            </article>
            <p>...</p>
            <article>
                <h3>Conclusión</h3>
                <p> Lo más complicado a la hora de elegir un buen nombre es que requiere habilidad descriptiva y acerbo cultural. Es un problemas más de formación más que técnico. Como resultado, mucha gente del sector no aprende a hacerlo bien</p>
            </article>
        </section>
        <section>
            <h2>Capítulo 3. Funciones</h2>
            <p>En la actualidad solo las funciones han sobrevido.</p>
            <p>Son la primera línea organizativa en cualquier programa.</p>
            <p>Ver <b>rederPageWithSetupsAndTeardowns()</b></p>
            <article>
                <h3>Tamaño reducido</h3>
                <p>La primera regla de las funciones es que deben ser de tamaño reducido.</p>
                <p>La segunda es que deben ser todavía más reducidas.</p>
            </article>
        </section>
    </div>
</body>
</html>